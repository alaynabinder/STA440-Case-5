---
title: "Analysis"
output: html_document
---

```{r}
library(tidyverse)
```

```{r}
load("strokeStudy.RData")
```

# EDA (MISSINGNESS)

```{r}
#| label: missingness-by-outcome

# Remove NAs from outcome
x <- x |>
  filter(!is.na(homeOrRehab))

missing_vars <- c("Age", "PreHospNotify", "EMSvsCar")

x_missing_outcome <- x |>
  mutate(
    homeOrRehab = factor(homeOrRehab),
    across(all_of(missing_vars), as.character)
  ) |>
  pivot_longer(
    cols = all_of(missing_vars),
    names_to = "variable",
    values_to = "value"
  ) |>
  mutate(is_missing = is.na(value)) |>
  group_by(variable, homeOrRehab) |>
  summarize(prop_missing = mean(is_missing), .groups = "drop")

ggplot(x_missing_outcome,
       aes(x = homeOrRehab, y = prop_missing, fill = homeOrRehab)) +
  geom_col() +
  facet_wrap(~ variable) +
  scale_y_continuous(labels = scales::percent_format()) +
  labs(
    title = "Missingness by Outcome",
    x = "Outcome",
    y = "Percent Missing"
  ) +
  theme_minimal() +
  theme(legend.position = "none")
```

```{r}
#| label: missingness-by-site-and-time

missing_by_site_time <- x |>
  select(siteID, Time2, all_of(missing_vars)) |>
  mutate(across(all_of(missing_vars), as.character)) |>
  pivot_longer(
    cols = all_of(missing_vars),
    names_to = "variable",
    values_to = "value"
  ) |>
  mutate(is_missing = is.na(value)) |>
  group_by(siteID, Time2, variable) |>
  summarize(prop_missing = mean(is_missing), .groups = "drop")

ggplot(missing_by_site_time,
       aes(x = Time2, y = siteID, fill = prop_missing)) +
  geom_tile() +
  facet_wrap(~ variable, nrow = 2) +
  scale_fill_continuous(labels = scales::percent_format()) +
  labs(
    title = "Missingness by Site and Time",
    x = "Study Quarter",
    y = "Site",
    fill = "Percent Missing"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 30, hjust = 1, size = 8),
    strip.text = element_text(size = 12)
  )

library(mice)
md.pattern(x,rotate.names = TRUE)
```

# DATA CLEANING / IMPUTATION

## Packages

```{r}
library(dplyr)
```

## Data Cleaning


```{r}
strokes <- x
strokes$EMSvsCar <- factor(strokes$EMSvsCar)

```

```{r}
strokes |> 
  group_by(hadTPA, tpaComplic) |>
  count()

```


```{r}

strokes <- strokes %>%
  mutate(TPA_group = case_when(
    hadTPA == FALSE ~ "NoTPA",
    hadTPA == TRUE & tpaComplic == FALSE ~ "TPA_NoComp",
    hadTPA == TRUE & tpaComplic == TRUE  ~ "TPA_Comp"
  ))

# Optional: make it a factor with ordered levels
strokes <- strokes %>%
  mutate(TPA_group = factor(TPA_group, levels = c("NoTPA", "TPA_NoComp", "TPA_Comp")))

# Check result
table(strokes$TPA_group)

strokes <- strokes |>
  select(-hadTPA) |>
  select(-TPA_group)

```
There is some correlation with hadTP and tpaComplication, so we made a new variable and removed the other two.


## Missingness

### First impute age, then EMS vs Car,  then Notify

I chose this order because of the dependency thing (unless I misunderstood that). 


PreHospNotify cannot be imputed without knowing EMSvsCar first. --> this is because when EMSvsCar = 1, PreHospNotify has be No.

See
```{r}
strokes |> group_by(strokes$EMSvsCar, PreHospNotify) |> count()
```


We need to maintain the constraint thought that if it's car, there won't be notify. --> I asked and because there's not a forced rule for when EMS vs Car equals 1, i.e. EMS could be PreHospNotify = YES or NO when it's 1. It recommended resolving using post-processing. 

```{r}
library(mice)

# Select relevant variables or full dataset
#data <- strokes |>
  #select(-siteID)

data <- strokes

# STEP 1: Specify imputation methods
# "" means: do NOT impute the variable
method <- make.method(data)

method["Age"] <- "pmm"
method["EMSvsCar"] <- "logreg"         # assuming it's binary
method["PreHospNotify"] <- "logreg"    # assuming it's binary

# Make sure NO OTHER variables are imputed
for (v in names(method)) {
  if (!v %in% c("Age", "EMSvsCar", "PreHospNotify")) {
    method[v] <- ""
  }
}

# STEP 2: Build predictor matrix
pred <- make.predictorMatrix(data)

# Remove self-prediction
pred["Age", "Age"] <- 0
pred["EMSvsCar", "EMSvsCar"] <- 0
pred["PreHospNotify", "PreHospNotify"] <- 0

# (OPTIONAL) If you want all variables to predict the three variables,
# keep predictor matrix as is.
# Or customize:
# pred["EMSvsCar", ] <- 0
# pred["EMSvsCar", c("Age")] <- 1

# STEP 3: Set the order of imputation
visitSequence <- c("Age", "EMSvsCar", "PreHospNotify")

# STEP 4: Run MICE
imp <- mice(
  data,
  m = 20,
  method = method,
  predictorMatrix = pred,
  visitSequence = visitSequence,
  maxit = 20,
  print = FALSE
)

```
### my post-processing

holds that all cases where EMS vs Car = 0, there won't be a prehospital notify  

```{r}
completed_list <- mice::complete(imp, action = "all")

# Define the categories exactly as they appear in your data
fix_rule <- function(df) {
  df$PreHospNotify[df$EMSvsCar == 0] <- "No"
  return(df)
}

completed_fixed <- lapply(completed_list, fix_rule)


```


### Rule out MNAR

Need to validate we can make the MAR assumption. These are diagnostics. 



```{r}
##### COMBINED SENSITIVITY ANALYSIS #####

library(dplyr)
library(mice)
library(broom)

# 1. Define delta values
delta_age <- c(-2, 0, 2, 5)                        # numeric adjustments
delta_ems <- c(-1, 0, 1)                            # 0/1 flips
delta_pre <- c("flip_to_no", "none", "flip_to_yes") # categorical flips

# 2. Loop through all deltas and adjust completed datasets
sensitivity_results <- list()

for(a in delta_age){
  for(e in delta_ems){
    for(p in delta_pre){
      
      # Adjust each completed dataset
      adjusted_dfs <- lapply(completed_fixed, function(df){
        df_new <- df
        
        # Age adjustment
        df_new$Age <- df_new$Age + a
        
        # EMSvsCar adjustment
        if(e == -1){
          df_new$EMSvsCar[df_new$EMSvsCar == 1] <- 0
        } else if(e == 1){
          df_new$EMSvsCar[df_new$EMSvsCar == 0] <- 1
        }
        
        # PreHospNotify adjustment
        if(p == "flip_to_no"){
          df_new$PreHospNotify[df_new$PreHospNotify == "Yes"] <- "No"
        } else if(p == "flip_to_yes"){
          df_new$PreHospNotify[df_new$PreHospNotify == "No"] <- "Yes"
        }
        
        return(df_new)
      })
      
      # Fit logistic regression on each imputed dataset
      model_list <- lapply(adjusted_dfs, function(df){
        glm(homeOrRehab ~ Age + EMSvsCar + PreHospNotify, 
            data = df, family = binomial)
      })
      
      # Pool results across imputations
      pooled <- pool(model_list)
      
      # Save results with scenario labels
      scenario_name <- paste0("Age_", a, "_EMS_", e, "_Pre_", p)
      sensitivity_results[[scenario_name]] <- summary(pooled)
      
    }
  }
}

# 3. Example: view results for one scenario
sensitivity_results[["Age_0_EMS_0_Pre_none"]]

```

##### Sensitivity for Age
```{r}
delta_values <- c(-2, 0, 2, 5)

library(dplyr)

sensitivity_age <- lapply(delta_values, function(delta) {
  adjusted <- complete(imp, "long") %>%
    mutate(Age = ifelse(.imp > 0, Age + delta, Age))
  
  list(delta = delta, data = adjusted)
})

```

### Sensitivity for EMS vs Car


```{r}
# Suppose EMSvsCar is 0/1
delta_binary <- c(-1, 0, 1) # meaning: flip 0→1 or 1→0 for sensitivity

sensitivity_ems <- lapply(delta_binary, function(delta) {
  lapply(completed_fixed, function(df) {
    df_new <- df
    if(delta == -1){
      df_new$EMSvsCar[df_new$EMSvsCar == 1] <- 0
    } else if(delta == 1){
      df_new$EMSvsCar[df_new$EMSvsCar == 0] <- 1
    }
    return(df_new)
  })
})

```



#### Sensitivity for PreHosp Notify

```{r}
delta_pre <- c("flip_to_no", "none", "flip_to_yes")

sensitivity_pre <- lapply(delta_pre, function(delta) {
  lapply(completed_fixed, function(df) {
    df_new <- df
    if(delta == "flip_to_no") {
      df_new$PreHospNotify[df_new$PreHospNotify == "Yes"] <- "No"
    } else if(delta == "flip_to_yes") {
      df_new$PreHospNotify[df_new$PreHospNotify == "No"] <- "Yes"
    }
    return(df_new)
  })
})

```

#### Sensitivity Results


```{r}
model_results <- lapply(sensitivity_age, function(s) {
  with(mice::as.mids(s$data), glm(StrokeOutcome ~ Age + EMSvsCar + PreHospNotify, family=binomial))
})

pooled_results <- lapply(model_results, pool)
```

```{r}

```

# EDA (POST IMPUTATION)

First is just checking the distributions pre and post imputation (they should be approximately the same):

```{r}
# Combining all completed datasets into a long dataframe
post_imp_long <- bind_rows(
  lapply(seq_along(completed_fixed), function(i) {
    completed_fixed[[i]] |> mutate(.imp = i)
  })
)

# Age
orig <- x |> mutate(.imp = "Original")

post_imp_long2 <- post_imp_long |> 
  mutate(.imp = as.character(.imp))

age_compare <- bind_rows(
  orig |> select(Age, .imp),
  post_imp_long2 |> select(Age, .imp)
)

ggplot(age_compare, aes(x = Age, fill = factor(.imp))) +
  geom_density(alpha = 0.2) +
  labs(
    title = "Age Distribution: Original vs. Imputed Datasets",
    x = "Age",
    y = "Density",
    fill = "Dataset"
  ) +
  theme_minimal()
```

```{r}
# EMSvsCar, PreHospNotify
orig_summary <- x |>
  summarize(
    EMSvsCar = mean(EMSvsCar == 1, na.rm = TRUE),
    PreHospNotify = mean(PreHospNotify == "Yes", na.rm = TRUE)
  ) |>
  mutate(.imp = "Original") |>
  pivot_longer(
    cols = c("EMSvsCar", "PreHospNotify"),
    names_to = "variable",
    values_to = "prop_yes"
  )

imp_summary <- post_imp_long |>
  mutate(
    .imp = as.character(.imp),
    EMSvsCar = as.numeric(as.character(EMSvsCar)),
    PreHospNotify = as.character(PreHospNotify)
  ) |>
  group_by(.imp) |>
  summarize(
    EMSvsCar = mean(EMSvsCar == 1, na.rm = TRUE),
    PreHospNotify = mean(PreHospNotify == "Yes", na.rm = TRUE)
  ) |>
  pivot_longer(
    cols = c("EMSvsCar", "PreHospNotify"),
    names_to = "variable",
    values_to = "prop_yes"
  )

binary_summary_all <- binary_summary_all |>
  mutate(
    .imp = factor(.imp, levels = c("Original", as.character(1:20)))
  )

ggplot(binary_summary_all, aes(x = .imp, y = prop_yes, fill = (.imp == "Original"))) +
  geom_col() +
  facet_wrap(~ variable, nrow = 1) +
  scale_fill_manual(values = c("grey70", "tomato"), guide = "none") +
  labs(
    title = "Proportion of Binary Variables: Original vs. Imputed Datasets",
    x = "Dataset",
    y = "Proportion 'Yes'"
  ) +
  coord_cartesian(ylim = c(0, 1)) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

Now onto EDA for association:

```{r fig.width=18, fig.height=10}
# just doing eda with 1st bc distributions roughly the same - obviously we would want to use all for prediction, but more lax in this case
eda_df <- completed_fixed[[1]] |>
  mutate(
    Disposition = factor(
      homeOrRehab,
      levels = c(0, 1),
      labels = c("Unfavorable Discharge", "Favorable Discharge")
    ),
    AgeGroup = cut(
      Age,
      breaks = c(0, 50, 65, 75, 85, Inf),
      labels = c("<50", "50–64", "65–74", "75–84", "85+"),
      right = FALSE
    ),
    Gender = factor(Gender),
    Race2 = factor(Race2),
    ArrivalMode = factor(EMSvsCar, labels = c("Car", "EMS")),
    PreHospitalNotification = factor(PreHospNotify),
    Thrombectomy = factor(hadThrombectomy),
    TPAComplication = factor(tpaComplic),
    ThrombectomyComplication = factor(thrComplic),
    StudyQuarter = factor(Time2)
  )

assoc_df <- eda_df |>
  select(
    Disposition,
    AgeGroup,
    Gender,
    Race2,
    ArrivalMode,
    PreHospitalNotification,
    Thrombectomy,
    TPAComplication,
    ThrombectomyComplication,
    StudyQuarter
  ) |>
  pivot_longer(
    cols = -Disposition,
    names_to = "Variable",
    values_to = "Level"
  ) |>
  group_by(Variable, Level) |>
  summarize(
    prop_favorable = mean(Disposition == "Favorable Discharge"),
    .groups = "drop"
  ) |>
  mutate(
    Variable = recode(
      Variable,
      AgeGroup = "Age Group",
      Gender = "Gender",
      Race2 = "Race",
      ArrivalMode = "Arrival Mode",
      PreHospitalNotification = "Pre-Hospital Notification",
      Thrombectomy = "Thrombectomy",
      TPAComplication = "TPA Complication",
      ThrombectomyComplication = "Thrombectomy Complication",
      StudyQuarter = "Study Quarter"
    )
  )

ggplot(assoc_df, aes(x = Level, y = prop_favorable)) +
  geom_col(fill = "#4472C4") +
  facet_wrap(~ Variable, scales = "free_x", nrow = 2) +
  scale_y_continuous(labels = scales::percent_format(), limits = c(0, 1)) +
  labs(
    title = "Association Between Predictors and Favorable Discharge",
    x = "",
    y = "Percent Favorable Discharge"
  ) +
  theme_minimal(base_size = 15) +
  theme(
    strip.text = element_text(face = "bold", size = 16),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 12),
    axis.text.y = element_text(size = 12),
    plot.title = element_text(size = 20, face = "bold")
  )
```
```{r}

```


# FREQUENTIST ANALYSIS

```{r}
library(pROC)
library(lme4)
results = NULL
AUCs = NULL
for (i in 1:20){
  data <- completed_fixed[[i]]
  data$homeOrRehab <- if_else(data$homeOrRehab,1,0)
  modelFit <- glm(factor(homeOrRehab) ~ . - tpaComplic , data = data, family = "binomial")
  AUCs <- c(AUCs,auc(data$homeOrRehab,predict(modelFit,data)))
  plot.roc(data$homeOrRehab,predict(modelFit,data))
  results <- c(results, list(summary(modelFit)))
}
results[[1]]$coefficients |> 
  as.data.frame() |> 
  select(-`z value`) |> 
  kableExtra::kable()
data.frame(iter = seq(1,20), AUC = AUCs) |> 
  kableExtra::kable()
```

# BAYESIAN ANALYSIS

```{r}
roc(data$homeOrRehab,predict(modelFit,data))
```

