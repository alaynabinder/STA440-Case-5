---
title: "Analysis"
output: pdf_document
---

```{r}
library(tidyverse)
```

```{r}
load("strokeStudy.RData")
```


```{r}
x$siteID <- as.character(x$siteID)
unique(x$siteID)

```


# EDA (MISSINGNESS)

```{r}
#| label: missingness-by-outcome

# Remove NAs from outcome
x <- x |>
  filter(!is.na(homeOrRehab))

missing_vars <- c("Age", "PreHospNotify", "EMSvsCar")

x_missing_outcome <- x |>
  mutate(
    homeOrRehab = factor(homeOrRehab),
    across(all_of(missing_vars), as.character)
  ) |>
  pivot_longer(
    cols = all_of(missing_vars),
    names_to = "variable",
    values_to = "value"
  ) |>
  mutate(is_missing = is.na(value)) |>
  group_by(variable, homeOrRehab) |>
  summarize(prop_missing = mean(is_missing), .groups = "drop")

ggplot(x_missing_outcome,
       aes(x = homeOrRehab, y = prop_missing, fill = homeOrRehab)) +
  geom_col() +
  facet_wrap(~ variable) +
  scale_y_continuous(labels = scales::percent_format()) +
  labs(
    title = "Missingness by Outcome",
    x = "Outcome",
    y = "Percent Missing"
  ) +
  theme_minimal() +
  theme(legend.position = "none")
```

```{r}
#| label: missingness-by-site-and-time

missing_by_site_time <- x |>
  select(siteID, Time2, all_of(missing_vars)) |>
  mutate(across(all_of(missing_vars), as.character)) |>
  pivot_longer(
    cols = all_of(missing_vars),
    names_to = "variable",
    values_to = "value"
  ) |>
  mutate(is_missing = is.na(value)) |>
  group_by(siteID, Time2, variable) |>
  summarize(prop_missing = mean(is_missing), .groups = "drop")

ggplot(missing_by_site_time,
       aes(x = Time2, y = siteID, fill = prop_missing)) +
  geom_tile() +
  facet_wrap(~ variable, nrow = 2) +
  scale_fill_continuous(labels = scales::percent_format()) +
  labs(
    title = "Missingness by Site and Time",
    x = "Study Quarter",
    y = "Site",
    fill = "Percent Missing"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 30, hjust = 1, size = 8),
    strip.text = element_text(size = 12)
  )

library(mice)
md.pattern(x,rotate.names = TRUE)
```

# DATA CLEANING / IMPUTATION

## Packages

```{r}
library(dplyr)
```

## Data Cleaning


```{r}
strokes <- x
strokes$EMSvsCar <- factor(strokes$EMSvsCar)

```

```{r}
strokes |> 
  group_by(hadTPA, tpaComplic) |>
  count()

```


```{r}

strokes <- strokes %>%
  mutate(TPA_group = case_when(
    hadTPA == FALSE ~ "NoTPA",
    hadTPA == TRUE & tpaComplic == FALSE ~ "TPA_NoComp",
    hadTPA == TRUE & tpaComplic == TRUE  ~ "TPA_Comp"
  ))

# Optional: make it a factor with ordered levels
strokes <- strokes %>%
  mutate(TPA_group = factor(TPA_group, levels = c("NoTPA", "TPA_NoComp", "TPA_Comp")))

# Check result
table(strokes$TPA_group)

strokes <- strokes |>
  select(-hadTPA) |>
  select(-tpaComplic)

```
There is some correlation with hadTP and tpaComplication, so we made a new variable and removed the other two.


## Missingness

### First impute age, then EMS vs Car,  then Notify

I chose this order because of the dependency thing (unless I misunderstood that). 


PreHospNotify cannot be imputed without knowing EMSvsCar first. --> this is because when EMSvsCar = 1, PreHospNotify has be No.

See
```{r}
strokes |> group_by(strokes$EMSvsCar, PreHospNotify) |> count()
```


We need to maintain the constraint thought that if it's car, there won't be notify. --> I asked and because there's not a forced rule for when EMS vs Car equals 1, i.e. EMS could be PreHospNotify = YES or NO when it's 1. It recommended resolving using post-processing. 



```{r}
library(mice)

# Select relevant variables or full dataset
#data <- strokes |>
  #select(-siteID)


strokes$siteID <-factor(strokes$siteID)
data <- strokes

# STEP 1: Specify imputation methods
# "" means: do NOT impute the variable
method <- make.method(data)

method["Age"] <- "pmm"
method["EMSvsCar"] <- "logreg"         # assuming it's binary
method["PreHospNotify"] <- "logreg"    # assuming it's binary

# Make sure NO OTHER variables are imputed
for (v in names(method)) {
  if (!v %in% c("Age", "EMSvsCar", "PreHospNotify")) {
    method[v] <- ""
  }
}

# STEP 2: Build predictor matrix
pred <- make.predictorMatrix(data)

# Remove self-prediction
pred["Age", "Age"] <- 0
pred["EMSvsCar", "EMSvsCar"] <- 0
pred["PreHospNotify", "PreHospNotify"] <- 0

# (OPTIONAL) If you want all variables to predict the three variables,
# keep predictor matrix as is.
# Or customize:
# pred["EMSvsCar", ] <- 0
# pred["EMSvsCar", c("Age")] <- 1

# STEP 3: Set the order of imputation
visitSequence <- c("Age", "EMSvsCar", "PreHospNotify")

# STEP 4: Run MICE
imp <- mice(
  data,
  m = 20,
  method = method,
  predictorMatrix = pred,
  visitSequence = visitSequence,
  maxit = 20,
  print = FALSE
)

```
### my post-processing

holds that all cases where EMS vs Car = 0, there won't be a prehospital notify  

```{r}
completed_list <- mice::complete(imp, action = "all")

# Define the categories exactly as they appear in your data
fix_rule <- function(df) {
  df$PreHospNotify[df$EMSvsCar == 0] <- "No"
  return(df)
}

completed_fixed <- lapply(completed_list, fix_rule)


```


### Rule out MNAR

Need to validate we can make the MAR assumption. These are diagnostics. 



```{r}
flip_some <- function(x, prop = 0.1) {
  # x: factor with 2 levels
  levels_x <- levels(x)
  if(length(levels_x) < 2) return(x)  # cannot flip
  idx <- sample(which(x == levels_x[1]), size = floor(prop*sum(x==levels_x[1])))
  x[idx] <- levels_x[2]
  return(x)
}

delta_age <- c(-1, 0, 1)  # small numeric shifts
delta_ems <- c(-1, 0, 1)  # only flip some cases
delta_pre <- c("flip_some", "none")

sensitivity_results <- list()

for(a in delta_age){
  for(e in delta_ems){
    for(pn in delta_pre){
      
      adjusted_dfs <- lapply(completed_fixed, function(df){
        df_new <- df
        
        # AGE adjustment
        df_new$Age <- df_new$Age + a
        
        # EMSvsCar adjustment (flip some)
        if(e != 0){
          df_new$EMSvsCar <- flip_some(df_new$EMSvsCar, prop = 0.1)
        }
        
        # PreHospNotify adjustment (flip some)
        if(pn == "flip_some"){
          df_new$PreHospNotify <- flip_some(df_new$PreHospNotify, prop = 0.1)
        }
        
        df_new
      })
      
      # Fit models and pool
      model_list <- lapply(adjusted_dfs, function(df){
        glm(homeOrRehab ~ Age + EMSvsCar + PreHospNotify,
            data = df, family = binomial)
      })
      
      pooled <- pool(model_list)
      pooled_summary <- summary(pooled)
      
      scenario_name <- paste0("Age_", a, "_EMS_", e, "_Pre_", pn)
      sensitivity_results[[scenario_name]] <- pooled_summary
    }
  }
}

```


```{r,eval=FALSE}
model_results <- lapply(sensitivity_age, function(s) {
  with(mice::as.mids(s$data), glm(StrokeOutcome ~ Age + EMSvsCar + PreHospNotify, family=binomial))
})

library(dplyr)

# Extract key variables (Age, EMSvsCar, PreHospNotify)
extract_var <- function(var_name){
  lapply(names(sensitivity_results), function(s){
    res <- sensitivity_results[[s]]
    
    # Skip if not a data frame
    if(!is.data.frame(res)) return(NULL)
    
    # Filter variable row
    df <- res %>%
      filter(term == var_name) %>%
      select(term, estimate, std.error, p.value) %>%
      mutate(scenario = s)
    
    df
  }) %>% bind_rows()
}

# Get estimates for each variable
age_results <- extract_var("Age")
ems_results <- extract_var("EMSvsCar")
pre_results <- extract_var("PreHospNotify")

```

```{r}
library(ggplot2)

# Combine all variables into one data frame for plotting
sensitivity_plot_data <- bind_rows(
  age_results %>% mutate(variable = "Age"),
  ems_results %>% mutate(variable = "EMSvsCar"),
  pre_results %>% mutate(variable = "PreHospNotify")
)

# Optional: create a simpler scenario label
sensitivity_plot_data <- sensitivity_plot_data %>%
  mutate(scenario_short = gsub("Age_|_EMS_|_Pre_", "", scenario))

# Plot
ggplot(sensitivity_plot_data, aes(x = scenario, y = estimate, color = variable)) +
  geom_point(position = position_dodge(width = 0.5)) +
  geom_errorbar(aes(ymin = estimate - 1.96*std.error, ymax = estimate + 1.96*std.error),
                width = 0.2, position = position_dodge(width = 0.5)) +
  facet_wrap(~ variable, scales = "free_y") +
  labs(
    title = "Sensitivity Analysis: Effect Estimates Across Scenarios",
    x = "Scenario",
    y = "Estimated Coefficient (log-odds)",
    color = "Variable"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```



# EDA (POST IMPUTATION)

First is just checking the distributions pre and post imputation (they should be approximately the same):

```{r}
# Combining all completed datasets into a long dataframe
post_imp_long <- bind_rows(
  lapply(seq_along(completed_fixed), function(i) {
    completed_fixed[[i]] |> mutate(.imp = i)
  })
)

# Age
orig <- x |> mutate(.imp = "Original")

post_imp_long2 <- post_imp_long |> 
  mutate(.imp = as.character(.imp))

age_compare <- bind_rows(
  orig |> select(Age, .imp),
  post_imp_long2 |> select(Age, .imp)
)

ggplot(age_compare, aes(x = Age, fill = factor(.imp))) +
  geom_density(alpha = 0.2) +
  labs(
    title = "Age Distribution: Original vs. Imputed Datasets",
    x = "Age",
    y = "Density",
    fill = "Dataset"
  ) +
  theme_minimal() +
  facet_wrap(~factor(.imp))
```

```{r,eval=FALSE}
# EMSvsCar, PreHospNotify
orig_summary <- x |>
  summarize(
    EMSvsCar = mean(EMSvsCar == 1, na.rm = TRUE),
    PreHospNotify = mean(PreHospNotify == "Yes", na.rm = TRUE)
  ) |>
  mutate(.imp = "Original") |>
  pivot_longer(
    cols = c("EMSvsCar", "PreHospNotify"),
    names_to = "variable",
    values_to = "prop_yes"
  )

imp_summary <- post_imp_long |>
  mutate(
    .imp = as.character(.imp),
    EMSvsCar = as.numeric(as.character(EMSvsCar)),
    PreHospNotify = as.character(PreHospNotify)
  ) |>
  group_by(.imp) |>
  summarize(
    EMSvsCar = mean(EMSvsCar == 1, na.rm = TRUE),
    PreHospNotify = mean(PreHospNotify == "Yes", na.rm = TRUE)
  ) |>
  pivot_longer(
    cols = c("EMSvsCar", "PreHospNotify"),
    names_to = "variable",
    values_to = "prop_yes"
  )

binary_summary_all <- binary_summary_all |>
  mutate(
    .imp = factor(.imp, levels = c("Original", as.character(1:20)))
  )

ggplot(binary_summary_all, aes(x = .imp, y = prop_yes, fill = (.imp == "Original"))) +
  geom_col() +
  facet_wrap(~ variable, nrow = 1) +
  scale_fill_manual(values = c("grey70", "tomato"), guide = "none") +
  labs(
    title = "Proportion of Binary Variables: Original vs. Imputed Datasets",
    x = "Dataset",
    y = "Proportion 'Yes'"
  ) +
  coord_cartesian(ylim = c(0, 1)) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

Now onto EDA for association:

```{r, fig.width=18, fig.height=10,eval=FALSE}
# just doing eda with 1st bc distributions roughly the same - obviously we would want to use all for prediction, but more lax in this case
assoc_df <- eda_df |>
  select(
    Disposition,
    AgeGroup,
    Gender,
    Race2,
    ArrivalMode,
    PreHospitalNotification,
    Thrombectomy,
    TPAComplication,
    ThrombectomyComplication,
    StudyQuarter
  ) |>
  pivot_longer(
    cols = -Disposition,
    names_to = "Variable",
    values_to = "Level"
  ) |>
  group_by(Variable, Level) |>
  summarize(
    n = n(),
    prop_favorable = mean(Disposition == "Favorable Discharge"),
    se = sqrt(prop_favorable * (1 - prop_favorable) / n),
    .groups = "drop"
  ) |>
  mutate(
    Variable = recode(
      Variable,
      AgeGroup = "Age Group",
      Gender = "Gender",
      Race2 = "Race",
      ArrivalMode = "Arrival Mode",
      PreHospitalNotification = "Pre-Hospital Notification",
      Thrombectomy = "Thrombectomy",
      TPAComplication = "TPA Complication",
      ThrombectomyComplication = "Thrombectomy Complication",
      StudyQuarter = "Study Quarter"
    )
  )

ggplot(assoc_df, aes(x = Level, y = prop_favorable)) +
  geom_col(fill = "#4472C4") +
  geom_errorbar(
    aes(
      ymin = prop_favorable - 1.96 * se,
      ymax = prop_favorable + 1.96 * se
    ),
    width = 0.2
  ) +
  facet_wrap(~ Variable, scales = "free_x", nrow = 2) +
  scale_y_continuous(labels = scales::percent_format(), limits = c(0, 1)) +
  labs(
    title = "Association Between Predictors and Favorable Discharge",
    x = "",
    y = "Percent Favorable Discharge"
  ) +
  theme_minimal(base_size = 15) +
  theme(
    strip.text = element_text(face = "bold", size = 16),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 12),
    axis.text.y = element_text(size = 12),
    plot.title = element_text(size = 20, face = "bold")
  )
```





# MODIFIED IMPUTATION
```{r}
library(rjags)


strokes$Age[strokes$Age == ""] <- NA
strokes$EMSvsCar[strokes$EMSvsCar == ""] <- NA
strokes$PreHospNotify[strokes$PreHospNotify == ""] <- NA

strokes$Race2[strokes$Race2 == "Missing"] <- NA
strokes$Race2 <- factor(strokes$Race2)

# Create NEW combined variable:
# 1 = Car (no notification)
# 2 = EMS w/o notification
# 3 = EMS w/ notification
strokes$TransportNotify <- with(
  strokes,
  ifelse(EMSvsCar == 0, 1,
         ifelse(PreHospNotify == 0, 2, 3))
)

# Convert to numeric categories for JAGS
strokes$siteID <- factor(strokes$siteID)
strokes$Race2 <- factor(strokes$Race2)

y_age  <- strokes$Age
y_tr   <- as.numeric(strokes$TransportNotify)
y_race <- as.numeric(strokes$Race2)
site   <- as.numeric(strokes$siteID)

N      <- nrow(strokes)
nsite  <- length(unique(site))
K_tr   <- 3     # new Transport/Notify categories
K_race <- length(levels(strokes$Race2))


jags_data <- list(
  N = N,
  age = y_age,
  tr = y_tr,
  race = y_race,
  site = site,
  nsite = nsite,
  K_tr = K_tr,
  K_race = K_race,
  alpha = rep(0.5, K_race)
)
inits_list <- list(
  list(
    mu_overall = 15,
    tau_age    = 1,
    tau_b      = 1,
    g_tr       = matrix(1, nsite, K_tr),       # stochastic node
    pi_race    = matrix(1/K_race, nsite, K_race) # stochastic node
  ),
  list(
    mu_overall = 60,
    tau_age    = 0.5,
    tau_b      = 2,
    g_tr       = matrix(0.5, nsite, K_tr),
    pi_race    = matrix(0.3, nsite, K_race)
  ),
  list(
    mu_overall = 30,
    tau_age    = 2,
    tau_b      = 1.5,
    g_tr       = matrix(0.2, nsite, K_tr),
    pi_race    = matrix(0.2, nsite, K_race)
  )
)


inits <- function() {
  list(
    mu_overall = 50,
    tau_age = 1,
    tau_b = 1
    # NO age, tr, race here!
    # pi_race and pi_tr if needed
  )
}

params <- c(
  "age", "tr", "race",      # missing data
  "mu_overall", "tau_age", "tau_b",  # hyperparameters
  "pi_tr", "pi_race",       # categorical probabilities
  "mu_site", "b_site"       # NEW: site-level means and random effects
)


jmod <- jags.model(
  "jags_impute_model.txt",
  data = jags_data,
  inits = inits_list,
  n.chains = 3,
  n.adapt = 1000
)


update(jmod, 2000)



samples <- coda.samples(
  jmod,
  variable.names = params,
  n.iter = 5000
)

samples

```

```{r}
# write model to file
model_string <- "
model {

  #### AGE MODEL (hierarchical by site) ####
  for (i in 1:N) {
    age[i] ~ dnorm(mu_site[site[i]], tau_age)
  }

  mu_overall ~ dnorm(0, 1.0E-6)
  tau_age    ~ dgamma(0.01, 0.01)
  sigma_age <- 1 / sqrt(tau_age)

  for (s in 1:nsite) {
    b_site[s] ~ dnorm(0, tau_b)
    mu_site[s] <- mu_overall + b_site[s]
  }

  tau_b ~ dgamma(0.01, 0.01)
  sigma_b <- 1 / sqrt(tau_b)


  #### TRANSPORT-NOTIFY MULTINOMIAL ####
  for (i in 1:N) {
    tr[i] ~ dcat(pi_tr[site[i],1:K_tr])
  }

  # Dirichlet prior via Gamma normalization
  for (s in 1:nsite) {

    for (k in 1:K_tr) {
      g_tr[s,k] ~ dgamma(1,1)
    }

    for (k in 1:K_tr) {
      pi_tr[s,k] <- g_tr[s,k] / sum(g_tr[s,1:K_tr])
    }

  }


  #### RACE MULTINOMIAL ####
  for (i in 1:N) {
    race[i] ~ dcat(pi_race[site[i],1:K_race])
  }

  for (s in 1:nsite) {
    pi_race[s,1:K_race] ~ ddirch(alpha[1:K_race])
  }

}

"

writeLines(model_string, con = 'jags_impute_model.txt')

```


```{r}
library(coda)

# Suppose you monitored only hyperparameters
samples_hyper <- samples[, c("mu_overall", "tau_age", "tau_b")]

# Gelman-Rubin diagnostic
gelman.diag(samples_hyper)

traceplot(samples_mcmc[, c("mu_overall", "tau_age", "tau_b")])
effectiveSize(samples_mcmc[, c("mu_overall", "tau_age", "tau_b")])


```

```{r}
library(ggplot2)
library(dplyr)
library(tidyr)

# -------------------------------
# 1. Extract posterior samples
# -------------------------------
samples_matrix <- as.matrix(samples)  # combine chains
samples_df <- as.data.frame(samples_matrix)

# -------------------------------
# 2. Define prior distributions
# -------------------------------

# Example for mu_overall ~ N(0, 1e6)
prior_mu <- function(x) dnorm(x, mean = 0, sd = sqrt(1e6))

# Example for tau_age, tau_b ~ Gamma(0.01, 0.01)
prior_gamma <- function(x) dgamma(x, shape = 0.01, rate = 0.01)

# -------------------------------
# 3. Make data frames for ggplot
# -------------------------------

# mu_overall
df_mu <- data.frame(
  x = seq(min(samples_df$mu_overall)-5, max(samples_df$mu_overall)+5, length.out = 500)
)
df_mu$prior <- prior_mu(df_mu$x)
df_mu$type <- "Prior"

df_mu_post <- data.frame(
  x = samples_df$mu_overall,
  density = NA,
  type = "Posterior"
)

# tau_age
df_tau <- data.frame(
  x = seq(0, max(samples_df$tau_age)*1.5, length.out = 500)
)
df_tau$prior <- prior_gamma(df_tau$x)
df_tau$type <- "Prior"

df_tau_post <- data.frame(
  x = samples_df$tau_age,
  density = NA,
  type = "Posterior"
)

# tau_b
df_tb <- data.frame(
  x = seq(0, max(samples_df$tau_b)*1.5, length.out = 500)
)
df_tb$prior <- prior_gamma(df_tb$x)
df_tb$type <- "Prior"

df_tb_post <- data.frame(
  x = samples_df$tau_b,
  density = NA,
  type = "Posterior"
)

# -------------------------------
# 4. Plotting
# -------------------------------

# Function to plot prior vs posterior
plot_prior_post <- function(df_prior, df_post, title) {
  ggplot() +
    geom_line(data = df_prior, aes(x = x, y = prior, color = "Prior"), size = 1) +
    geom_histogram(data = df_post, aes(x = x, y = ..density.., fill = "Posterior"),
                   bins = 50, alpha = 0.5, position = "identity") +
    scale_color_manual("", values = c("Prior" = "blue")) +
    scale_fill_manual("", values = c("Posterior" = "orange")) +
    theme_minimal() +
    labs(title = title, x = "", y = "Density")
}

# Plot mu_overall
plot_prior_post(df_mu, df_mu_post, "mu_overall")

# Plot tau_age
plot_prior_post(df_tau, df_tau_post, "tau_age")

# Plot tau_b
plot_prior_post(df_tb, df_tb_post, "tau_b")

```

```{r}
library(coda)

# -------------------------------
# 1. Convert coda samples to matrix
# -------------------------------
samples_matrix <- as.matrix(samples)

# -------------------------------
# 2. Identify missing indices
# -------------------------------
missing_age  <- which(is.na(y_age))
missing_tr   <- which(is.na(y_tr))
missing_race <- which(is.na(y_race))

# -------------------------------
# 3. Function to create one imputed dataset
# -------------------------------
impute_dataset <- function(samples_matrix, y_age, y_tr, y_race) {
  y_age_imp  <- y_age
  y_tr_imp   <- y_tr
  y_race_imp <- y_race

  # Impute age (continuous)
  for (i in missing_age) {
    varname <- paste0("age[", i, "]")
    draws <- samples_matrix[, varname]
    y_age_imp[i] <- sample(draws, 1)
  }

  # Impute transport-notify (categorical)
  for (i in missing_tr) {
    varname <- paste0("tr[", i, "]")
    draws <- samples_matrix[, varname]
    tab <- table(draws)
    # Random draw from posterior probabilities
    y_tr_imp[i] <- as.numeric(sample(names(tab), 1, prob = tab))
  }

  # Impute race (categorical)
  for (i in missing_race) {
    varname <- paste0("race[", i, "]")
    draws <- samples_matrix[, varname]
    tab <- table(draws)
    y_race_imp[i] <- as.numeric(sample(names(tab), 1, prob = tab))
  }

  # Create completed dataset
  df <- strokes
  df$Age <- y_age_imp
  df$TransportNotify <- y_tr_imp
  df$Race2 <- factor(y_race_imp, levels = 1:K_race)
  return(df)
}

# -------------------------------
# 4. Generate multiple imputed datasets
# -------------------------------
m <- 5  # number of imputed datasets
imputed_list <- vector("list", m)

set.seed(123)  # reproducible
for (j in 1:m) {
  imputed_list[[j]] <- impute_dataset(samples_matrix, y_age, y_tr, y_race)
}

# Now imputed_list[[1]], imputed_list[[2]], ... are your datasets

```

```{r}
library(ggplot2)
library(dplyr)

# 1. Extract posterior means for mu_site
# Assuming mu_site[s] is monitored in your JAGS model
if(!"mu_site[1]" %in% colnames(samples_matrix)) {
  stop("You need to monitor mu_site[s] in your JAGS model")
}

mu_site_post <- samples_matrix[, grep("^mu_site\\[", colnames(samples_matrix))]
mu_site_mean <- colMeans(mu_site_post)  # posterior mean per site

# 2. Compute residuals: observed age - posterior mean per site
residuals <- y_age - mu_site_mean[site]

# 3. Residual normality check
ggplot(data.frame(residuals = residuals), aes(sample = residuals)) +
  stat_qq() +
  stat_qq_line(color = "red") +
  ggtitle("QQ-Plot of Age Residuals") +
  theme_minimal()

# 4. Histogram of residuals
ggplot(data.frame(residuals = residuals), aes(x = residuals)) +
  geom_histogram(aes(y = ..density..), bins = 30, fill = "skyblue", alpha = 0.6) +
  geom_density(color = "red") +
  ggtitle("Histogram of Age Residuals") +
  theme_minimal()

# 5. Check variance across sites
residuals_df <- data.frame(residuals = residuals, site = factor(site))
ggplot(residuals_df, aes(x = site, y = residuals)) +
  geom_boxplot(fill = "lightgreen", alpha = 0.6) +
  ggtitle("Residuals by Site") +
  ylab("Age residuals") +
  theme_minimal()

# 6. Inspect site-level random effects
b_site_post <- samples_matrix[, grep("^b_site\\[", colnames(samples_matrix))]
b_site_mean <- colMeans(b_site_post)

ggplot(data.frame(b_site = b_site_mean, site = factor(1:nsite)),
       aes(x = site, y = b_site)) +
  geom_point(size = 3, color = "blue") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  ggtitle("Posterior Mean of Site-level Random Effects") +
  ylab("b_site") +
  theme_minimal()

```


# FREQUENTIST ANALYSIS

```{r}
library(pROC)
library(lme4)
results = NULL
AUCs = NULL
for (i in 1:20){
  data <- completed_fixed[[i]]
  data$homeOrRehab <- if_else(data$homeOrRehab,1,0)
  modelFit <- glm(factor(homeOrRehab) ~ ., data = data, family = "binomial")
  AUCs <- c(AUCs,auc(data$homeOrRehab,predict(modelFit,data)))
  results <- c(results, list(summary(modelFit)))
}
arm::binnedplot(fitted(modelFit),residuals(modelFit))
plot.roc(data$homeOrRehab,predict(modelFit,data))
results[[1]]$coefficients |> 
  as.data.frame() |> 
  select(-`z value`) |> 
  kableExtra::kable()
data.frame(iter = seq(1,20), AUC = AUCs) |> 
  kableExtra::kable()
```

# BAYESIAN ANALYSIS
{{< pagebreak >}}
```{r}
library(rstan)
data <- data |> 
  mutate(raceAfricanAmerican = if_else(Race2 == "African American",1,0),
         raceOther = if_else(Race2 == "Other",1,0),
         raceCaucasian = if_else(Race2 == "Caucasian",1,0)) |> 
  select(-Race2)
Y <- as.integer(data$homeOrRehab)
X <- model.matrix(~.,data =data[2:13])[,-1]
X <- X[,-14]
Ids <- as.numeric(data$siteID)
n <- length(unique(Ids))
N <- nrow(X)
p <- ncol(X)
stan_data <- list(
  Y = Y,
  X = X,
  Ids = Ids,
  n = n,
  N = N,
  p = p
)
compiled_model <- stan_model(file = "logRegRE.stan")
options(mc.cores = 4)
fit <- sampling(compiled_model, data = stan_data)
print(fit, pars = c("alpha", "beta", "theta","tau"), probs = c(0.025, 0.5, 0.975))

library(bayesplot)
Y_pred <- rstan::extract(fit, pars = "Y_pred")$Y_pred
ppc_bars(Y, Y_pred[1:100, ])
ppc_bars_grouped(Y, Y_pred[1:100, ],data$Gender)
traceplot(fit, pars = c("alpha","beta"))
mcmc_acf(fit, regex_pars = c("alpha","beta"))
```

