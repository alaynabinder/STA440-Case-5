---
title: "Analysis"
output: pdf_document
---

```{r}
library(tidyverse)
```

```{r}
load("strokeStudy.RData")
```


```{r}
x$siteID <- as.character(x$siteID)
unique(x$siteID)

```


# EDA (MISSINGNESS)

```{r}
#| label: missingness-by-outcome

# Remove NAs from outcome
x <- x |>
  filter(!is.na(homeOrRehab))

missing_vars <- c("Age", "PreHospNotify", "EMSvsCar")

x_missing_outcome <- x |>
  mutate(
    homeOrRehab = factor(homeOrRehab),
    across(all_of(missing_vars), as.character)
  ) |>
  pivot_longer(
    cols = all_of(missing_vars),
    names_to = "variable",
    values_to = "value"
  ) |>
  mutate(is_missing = is.na(value)) |>
  group_by(variable, homeOrRehab) |>
  summarize(prop_missing = mean(is_missing), .groups = "drop")

ggplot(x_missing_outcome,
       aes(x = homeOrRehab, y = prop_missing, fill = homeOrRehab)) +
  geom_col() +
  facet_wrap(~ variable) +
  scale_y_continuous(labels = scales::percent_format()) +
  labs(
    title = "Missingness by Outcome",
    x = "Outcome",
    y = "Percent Missing"
  ) +
  theme_minimal() +
  theme(legend.position = "none")
```

```{r}
#| label: missingness-by-site-and-time

missing_by_site_time <- x |>
  select(siteID, Time2, all_of(missing_vars)) |>
  mutate(across(all_of(missing_vars), as.character)) |>
  pivot_longer(
    cols = all_of(missing_vars),
    names_to = "variable",
    values_to = "value"
  ) |>
  mutate(is_missing = is.na(value)) |>
  group_by(siteID, Time2, variable) |>
  summarize(prop_missing = mean(is_missing), .groups = "drop")

ggplot(missing_by_site_time,
       aes(x = Time2, y = siteID, fill = prop_missing)) +
  geom_tile() +
  facet_wrap(~ variable, nrow = 2) +
  scale_fill_continuous(labels = scales::percent_format()) +
  labs(
    title = "Missingness by Site and Time",
    x = "Study Quarter",
    y = "Site",
    fill = "Percent Missing"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 30, hjust = 1, size = 8),
    strip.text = element_text(size = 12)
  )

library(mice)
md.pattern(x,rotate.names = TRUE)
```

# DATA CLEANING / IMPUTATION

## Packages

```{r}
library(dplyr)
```

## Data Cleaning


```{r}
strokes <- x
strokes$EMSvsCar <- factor(strokes$EMSvsCar)

```

```{r}
strokes |> 
  group_by(hadTPA, tpaComplic) |>
  count()

```


```{r}

strokes <- strokes %>%
  mutate(TPA_group = case_when(
    hadTPA == FALSE ~ "NoTPA",
    hadTPA == TRUE & tpaComplic == FALSE ~ "TPA_NoComp",
    hadTPA == TRUE & tpaComplic == TRUE  ~ "TPA_Comp"
  ))

# Optional: make it a factor with ordered levels
strokes <- strokes %>%
  mutate(TPA_group = factor(TPA_group, levels = c("NoTPA", "TPA_NoComp", "TPA_Comp")))

# Check result
table(strokes$TPA_group)

strokes <- strokes |>
  select(-hadTPA) |>
  select(-tpaComplic)

```
There is some correlation with hadTP and tpaComplication, so we made a new variable and removed the other two.


## Missingness

### First impute age, then EMS vs Car,  then Notify

I chose this order because of the dependency thing (unless I misunderstood that). 


PreHospNotify cannot be imputed without knowing EMSvsCar first. --> this is because when EMSvsCar = 1, PreHospNotify has be No.

See
```{r}
strokes |> group_by(strokes$EMSvsCar, PreHospNotify) |> count()
```


We need to maintain the constraint thought that if it's car, there won't be notify. --> I asked and because there's not a forced rule for when EMS vs Car equals 1, i.e. EMS could be PreHospNotify = YES or NO when it's 1. It recommended resolving using post-processing. 



```{r}
library(mice)

# Select relevant variables or full dataset
#data <- strokes |>
  #select(-siteID)


strokes$siteID <-factor(strokes$siteID)
data <- strokes

# STEP 1: Specify imputation methods
# "" means: do NOT impute the variable
method <- make.method(data)

method["Age"] <- "pmm"
method["EMSvsCar"] <- "logreg"         # assuming it's binary
method["PreHospNotify"] <- "logreg"    # assuming it's binary

# Make sure NO OTHER variables are imputed
for (v in names(method)) {
  if (!v %in% c("Age", "EMSvsCar", "PreHospNotify")) {
    method[v] <- ""
  }
}

# STEP 2: Build predictor matrix
pred <- make.predictorMatrix(data)

# Remove self-prediction
pred["Age", "Age"] <- 0
pred["EMSvsCar", "EMSvsCar"] <- 0
pred["PreHospNotify", "PreHospNotify"] <- 0

# (OPTIONAL) If you want all variables to predict the three variables,
# keep predictor matrix as is.
# Or customize:
# pred["EMSvsCar", ] <- 0
# pred["EMSvsCar", c("Age")] <- 1

# STEP 3: Set the order of imputation
visitSequence <- c("Age", "EMSvsCar", "PreHospNotify")

# STEP 4: Run MICE
imp <- mice(
  data,
  m = 20,
  method = method,
  predictorMatrix = pred,
  visitSequence = visitSequence,
  maxit = 20,
  print = FALSE
)

```
### my post-processing

holds that all cases where EMS vs Car = 0, there won't be a prehospital notify  

```{r}
completed_list <- mice::complete(imp, action = "all")

# Define the categories exactly as they appear in your data
fix_rule <- function(df) {
  df$PreHospNotify[df$EMSvsCar == 0] <- "No"
  return(df)
}

completed_fixed <- lapply(completed_list, fix_rule)


```


### Rule out MNAR

Need to validate we can make the MAR assumption. These are diagnostics. 



```{r}
##### SENSITIVITY ANALYSIS — Age + EMSvsCar + PreHospNotify #####

library(dplyr)
library(mice)
library(broom)

# 1. Define delta values
delta_age <- c(-2, 0, 2, 5)                        # numeric adjustments
delta_ems <- c(-1, 0, 1)                           # 0/1 flips
delta_pre <- c("flip_to_no", "none", "flip_to_yes")# categorical flips

# Storage
sensitivity_results <- list()

# 2. Loop through all effects
for(a in delta_age){
  for(e in delta_ems){
    for(pn in delta_pre){
      
      adjusted_dfs <- lapply(completed_fixed, function(df){
        df_new <- df
        
        ##### AGE adjustment #####
        df_new$Age <- df_new$Age + a
        
        ##### EMSvsCar flips #####
        if(e == -1){
          df_new$EMSvsCar[df_new$EMSvsCar == 1] <- 0
        } else if(e == 1){
          df_new$EMSvsCar[df_new$EMSvsCar == 0] <- 1
        }
        
        ##### PreHospNotify flips #####
        if(pn == "flip_to_no"){
          df_new$PreHospNotify[df_new$PreHospNotify == "Yes"] <- "No"
        } else if(pn == "flip_to_yes"){
          df_new$PreHospNotify[df_new$PreHospNotify == "No"] <- "Yes"
        }
        
        ##### SAFETY CHECKS #####
        # EMSvsCar must have 2 levels
        if(length(unique(df_new$EMSvsCar)) < 2){
          return(NULL)
        }
        
        # PreHospNotify must have 2 levels
        if(length(unique(df_new$PreHospNotify)) < 2){
          return(NULL)
        }
        
        df_new
      })
      
      # Remove NULL datasets created by safety checks
      adjusted_dfs <- Filter(Negate(is.null), adjusted_dfs)
      
      # If ALL datasets collapsing → skip scenario
      if(length(adjusted_dfs) == 0){
        scenario_name <- paste0("Age_", a, "_EMS_", e, "_Pre_", pn)
        sensitivity_results[[scenario_name]] <- "SKIPPED (variable collapsed)"
        next
      }
      
      ##### Fit logistic models #####
      model_list <- lapply(adjusted_dfs, function(df){
        glm(
          homeOrRehab ~ Age + EMSvsCar + PreHospNotify,
          data = df,
          family = binomial
        )
      })
      
      ##### Pool results #####
      pooled <- pool(model_list)
      pooled_summary <- summary(pooled)
      
      ##### Save scenario #####
      scenario_name <- paste0("Age_", a, "_EMS_", e, "_Pre_", pn)
      sensitivity_results[[scenario_name]] <- pooled_summary
    }
  }
}

##### 3. Example: view a scenario #####
sensitivity_results[["Age_0_EMS_0_Pre_none"]]

```


```{r,eval=FALSE}
model_results <- lapply(sensitivity_age, function(s) {
  with(mice::as.mids(s$data), glm(StrokeOutcome ~ Age + EMSvsCar + PreHospNotify, family=binomial))
})

pooled_results <- lapply(model_results, pool)
```

```{r}

```

# EDA (POST IMPUTATION)

First is just checking the distributions pre and post imputation (they should be approximately the same):

```{r}
# Combining all completed datasets into a long dataframe
post_imp_long <- bind_rows(
  lapply(seq_along(completed_fixed), function(i) {
    completed_fixed[[i]] |> mutate(.imp = i)
  })
)

# Age
orig <- x |> mutate(.imp = "Original")

post_imp_long2 <- post_imp_long |> 
  mutate(.imp = as.character(.imp))

age_compare <- bind_rows(
  orig |> select(Age, .imp),
  post_imp_long2 |> select(Age, .imp)
)

ggplot(age_compare, aes(x = Age, fill = factor(.imp))) +
  geom_density(alpha = 0.2) +
  labs(
    title = "Age Distribution: Original vs. Imputed Datasets",
    x = "Age",
    y = "Density",
    fill = "Dataset"
  ) +
  theme_minimal()
```

```{r,eval=FALSE}
# EMSvsCar, PreHospNotify
orig_summary <- x |>
  summarize(
    EMSvsCar = mean(EMSvsCar == 1, na.rm = TRUE),
    PreHospNotify = mean(PreHospNotify == "Yes", na.rm = TRUE)
  ) |>
  mutate(.imp = "Original") |>
  pivot_longer(
    cols = c("EMSvsCar", "PreHospNotify"),
    names_to = "variable",
    values_to = "prop_yes"
  )

imp_summary <- post_imp_long |>
  mutate(
    .imp = as.character(.imp),
    EMSvsCar = as.numeric(as.character(EMSvsCar)),
    PreHospNotify = as.character(PreHospNotify)
  ) |>
  group_by(.imp) |>
  summarize(
    EMSvsCar = mean(EMSvsCar == 1, na.rm = TRUE),
    PreHospNotify = mean(PreHospNotify == "Yes", na.rm = TRUE)
  ) |>
  pivot_longer(
    cols = c("EMSvsCar", "PreHospNotify"),
    names_to = "variable",
    values_to = "prop_yes"
  )

binary_summary_all <- binary_summary_all |>
  mutate(
    .imp = factor(.imp, levels = c("Original", as.character(1:20)))
  )

ggplot(binary_summary_all, aes(x = .imp, y = prop_yes, fill = (.imp == "Original"))) +
  geom_col() +
  facet_wrap(~ variable, nrow = 1) +
  scale_fill_manual(values = c("grey70", "tomato"), guide = "none") +
  labs(
    title = "Proportion of Binary Variables: Original vs. Imputed Datasets",
    x = "Dataset",
    y = "Proportion 'Yes'"
  ) +
  coord_cartesian(ylim = c(0, 1)) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

Now onto EDA for association:

```{r, fig.width=18, fig.height=10,eval=FALSE}
# just doing eda with 1st bc distributions roughly the same - obviously we would want to use all for prediction, but more lax in this case
assoc_df <- eda_df |>
  select(
    Disposition,
    AgeGroup,
    Gender,
    Race2,
    ArrivalMode,
    PreHospitalNotification,
    Thrombectomy,
    TPAComplication,
    ThrombectomyComplication,
    StudyQuarter
  ) |>
  pivot_longer(
    cols = -Disposition,
    names_to = "Variable",
    values_to = "Level"
  ) |>
  group_by(Variable, Level) |>
  summarize(
    n = n(),
    prop_favorable = mean(Disposition == "Favorable Discharge"),
    se = sqrt(prop_favorable * (1 - prop_favorable) / n),
    .groups = "drop"
  ) |>
  mutate(
    Variable = recode(
      Variable,
      AgeGroup = "Age Group",
      Gender = "Gender",
      Race2 = "Race",
      ArrivalMode = "Arrival Mode",
      PreHospitalNotification = "Pre-Hospital Notification",
      Thrombectomy = "Thrombectomy",
      TPAComplication = "TPA Complication",
      ThrombectomyComplication = "Thrombectomy Complication",
      StudyQuarter = "Study Quarter"
    )
  )

ggplot(assoc_df, aes(x = Level, y = prop_favorable)) +
  geom_col(fill = "#4472C4") +
  geom_errorbar(
    aes(
      ymin = prop_favorable - 1.96 * se,
      ymax = prop_favorable + 1.96 * se
    ),
    width = 0.2
  ) +
  facet_wrap(~ Variable, scales = "free_x", nrow = 2) +
  scale_y_continuous(labels = scales::percent_format(), limits = c(0, 1)) +
  labs(
    title = "Association Between Predictors and Favorable Discharge",
    x = "",
    y = "Percent Favorable Discharge"
  ) +
  theme_minimal(base_size = 15) +
  theme(
    strip.text = element_text(face = "bold", size = 16),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 12),
    axis.text.y = element_text(size = 12),
    plot.title = element_text(size = 20, face = "bold")
  )
```


# FREQUENTIST ANALYSIS

```{r}
library(pROC)
library(lme4)
results = NULL
AUCs = NULL
for (i in 1:20){
  data <- completed_fixed[[i]]
  data$homeOrRehab <- if_else(data$homeOrRehab,1,0)
  modelFit <- glm(factor(homeOrRehab) ~ ., data = data, family = "binomial")
  AUCs <- c(AUCs,auc(data$homeOrRehab,predict(modelFit,data)))
  results <- c(results, list(summary(modelFit)))
}
arm::binnedplot(fitted(modelFit),residuals(modelFit))
plot.roc(data$homeOrRehab,predict(modelFit,data))
results[[1]]$coefficients |> 
  as.data.frame() |> 
  select(-`z value`) |> 
  kableExtra::kable()
data.frame(iter = seq(1,20), AUC = AUCs) |> 
  kableExtra::kable()
```

# BAYESIAN ANALYSIS
{{< pagebreak >}}
```{r}
library(rstan)
data <- data |> 
  mutate(raceAfricanAmerican = if_else(Race2 == "African American",1,0),
         raceOther = if_else(Race2 == "Other",1,0),
         raceCaucasian = if_else(Race2 == "Caucasian",1,0)) |> 
  select(-Race2)
Y <- as.integer(data$homeOrRehab)
X <- model.matrix(~.,data =data[2:13])[,-1]
X <- X[,-14]
Ids <- as.numeric(data$siteID)
n <- length(unique(Ids))
N <- nrow(X)
p <- ncol(X)
stan_data <- list(
  Y = Y,
  X = X,
  Ids = Ids,
  n = n,
  N = N,
  p = p
)
compiled_model <- stan_model(file = "logRegRE.stan")
options(mc.cores = 4)
fit <- sampling(compiled_model, data = stan_data)
print(fit, pars = c("alpha", "beta", "theta","tau"), probs = c(0.025, 0.5, 0.975))

library(bayesplot)
Y_pred <- rstan::extract(fit, pars = "Y_pred")$Y_pred
ppc_bars(Y, Y_pred[1:100, ])
ppc_bars_grouped(Y, Y_pred[1:100, ],data$Gender)
traceplot(fit, pars = c("alpha","beta"))
mcmc_acf(fit, regex_pars = c("alpha","beta"))
```

